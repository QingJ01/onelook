/**
 * FreeMind 格式转换器
 * 支持 FreeMind 的 .mm XML 格式
 */

import type { MindMapNode, MindMapDocument, NodeStyle, NodeData } from '@/types'
import { v4 as uuidv4 } from 'uuid'

export const freemindConverter = {
    /**
     * 从 FreeMind 文件导入
     */
    async import(file: File): Promise<MindMapDocument> {
        const text = await file.text()
        const parser = new DOMParser()
        const doc = parser.parseFromString(text, 'application/xml')

        // 检查解析错误
        const parseError = doc.querySelector('parsererror')
        if (parseError) {
            throw new Error('无效的 FreeMind 文件：XML 解析错误')
        }

        // 获取根节点
        const mapElement = doc.querySelector('map')
        if (!mapElement) {
            throw new Error('无效的 FreeMind 文件：找不到 map 元素')
        }

        const rootNode = mapElement.querySelector(':scope > node')
        if (!rootNode) {
            throw new Error('无效的 FreeMind 文件：找不到根节点')
        }

        // 转换为 OneLook 格式
        const root = convertFreeMindNode(rootNode)

        return {
            id: uuidv4(),
            name: root.text || file.name.replace(/\.mm$/i, ''),
            root,
            layout: 'mind',
            theme: 'light',
            createdAt: Date.now(),
            updatedAt: Date.now(),
            version: '0.1.0'
        }
    },

    /**
     * 导出为 FreeMind 格式
     */
    async export(doc: MindMapDocument): Promise<Blob> {
        const xmlContent = generateFreeMindXML(doc)
        return new Blob([xmlContent], { type: 'application/xml;charset=utf-8' })
    }
}

/**
 * 将 FreeMind 节点转换为 OneLook 节点
 */
function convertFreeMindNode(element: Element, parentId?: string): MindMapNode {
    const node: MindMapNode = {
        id: uuidv4(),
        text: element.getAttribute('TEXT') || '',
        parentId,
        children: [],
        isExpanded: element.getAttribute('FOLDED') !== 'true'
    }

    // 转换样式
    const style: NodeStyle = {}

    const bgColor = element.getAttribute('BACKGROUND_COLOR')
    if (bgColor) {
        style.background = bgColor
    }

    const color = element.getAttribute('COLOR')
    if (color) {
        style.color = color
    }

    // 查找 font 元素
    const fontElement = element.querySelector(':scope > font')
    if (fontElement) {
        const fontSize = fontElement.getAttribute('SIZE')
        if (fontSize) {
            style.fontSize = parseInt(fontSize)
        }
        if (fontElement.getAttribute('BOLD') === 'true') {
            style.fontWeight = 'bold'
        }
    }

    // 节点形状
    const styleAttr = element.getAttribute('STYLE')
    if (styleAttr) {
        const shapeMap: Record<string, NodeStyle['shape']> = {
            'bubble': 'round',
            'rectangle': 'rect',
            'fork': 'rect'
        }
        if (shapeMap[styleAttr]) {
            style.shape = shapeMap[styleAttr]
        }
    }

    if (Object.keys(style).length > 0) {
        node.style = style
    }

    // 转换扩展数据
    const data: NodeData = {}

    // 链接
    const link = element.getAttribute('LINK')
    if (link) {
        data.hyperlink = link
    }

    // 备注（richcontent 元素）
    const noteElement = element.querySelector(':scope > richcontent[TYPE="NOTE"]')
    if (noteElement) {
        // 提取纯文本
        data.note = noteElement.textContent?.trim() || ''
    }

    // 图标（转换为优先级或进度）
    const icons = element.querySelectorAll(':scope > icon')
    icons.forEach(icon => {
        const builtin = icon.getAttribute('BUILTIN')
        if (builtin) {
            // 优先级图标
            if (builtin.startsWith('full-')) {
                const priority = parseInt(builtin.replace('full-', ''))
                if (priority >= 1 && priority <= 9) {
                    data.priority = priority
                }
            }
            // 进度图标
            const progressMap: Record<string, number> = {
                'hourglass': 0,
                '25%': 25,
                '50%': 50,
                '75%': 75,
                'button_ok': 100
            }
            if (progressMap[builtin] !== undefined) {
                data.progress = progressMap[builtin]
            }
        }
    })

    if (Object.keys(data).length > 0) {
        node.data = data
    }

    // 递归转换子节点
    const childNodes = element.querySelectorAll(':scope > node')
    node.children = Array.from(childNodes).map(child =>
        convertFreeMindNode(child, node.id)
    )

    return node
}

/**
 * 生成 FreeMind XML
 */
function generateFreeMindXML(doc: MindMapDocument): string {
    const lines: string[] = []
    lines.push('<?xml version="1.0" encoding="UTF-8"?>')
    lines.push('<map version="1.0.1">')
    lines.push('<!-- Generated by OneLook -->')

    generateNodeXML(doc.root, lines, 1)

    lines.push('</map>')
    return lines.join('\n')
}

/**
 * 生成节点 XML
 */
function generateNodeXML(node: MindMapNode, lines: string[], indent: number): void {
    const indentStr = '  '.repeat(indent)
    const attrs: string[] = []

    // 文本属性
    attrs.push(`TEXT="${escapeXML(node.text)}"`)

    // 折叠状态
    if (!node.isExpanded && node.children.length > 0) {
        attrs.push('FOLDED="true"')
    }

    // 样式属性
    if (node.style) {
        if (node.style.background) {
            attrs.push(`BACKGROUND_COLOR="${node.style.background}"`)
        }
        if (node.style.color) {
            attrs.push(`COLOR="${node.style.color}"`)
        }
        if (node.style.shape) {
            const shapeMap: Record<string, string> = {
                'round': 'bubble',
                'rect': 'rectangle',
                'diamond': 'rectangle',
                'ellipse': 'bubble'
            }
            attrs.push(`STYLE="${shapeMap[node.style.shape] || 'bubble'}"`)
        }
    }

    // 链接
    if (node.data?.hyperlink) {
        attrs.push(`LINK="${escapeXML(node.data.hyperlink)}"`)
    }

    const hasChildren = node.children.length > 0
    const hasFont = node.style?.fontSize || node.style?.fontWeight === 'bold'
    const hasNote = node.data?.note
    const hasIcons = node.data?.priority || node.data?.progress !== undefined

    if (hasChildren || hasFont || hasNote || hasIcons) {
        lines.push(`${indentStr}<node ${attrs.join(' ')}>`)

        // 字体元素
        if (hasFont) {
            const fontAttrs: string[] = []
            if (node.style?.fontSize) {
                fontAttrs.push(`SIZE="${node.style.fontSize}"`)
            }
            if (node.style?.fontWeight === 'bold') {
                fontAttrs.push('BOLD="true"')
            }
            lines.push(`${indentStr}  <font ${fontAttrs.join(' ')}/>`)
        }

        // 图标
        if (node.data?.priority) {
            lines.push(`${indentStr}  <icon BUILTIN="full-${node.data.priority}"/>`)
        }
        if (node.data?.progress !== undefined) {
            const progressMap: Record<number, string> = {
                0: 'hourglass',
                25: '25%',
                50: '50%',
                75: '75%',
                100: 'button_ok'
            }
            const closest = Object.keys(progressMap)
                .map(Number)
                .reduce((prev, curr) =>
                    Math.abs(curr - node.data!.progress!) < Math.abs(prev - node.data!.progress!)
                        ? curr : prev
                )
            lines.push(`${indentStr}  <icon BUILTIN="${progressMap[closest]}"/>`)
        }

        // 备注
        if (hasNote) {
            lines.push(`${indentStr}  <richcontent TYPE="NOTE">`)
            lines.push(`${indentStr}    <html>`)
            lines.push(`${indentStr}      <head></head>`)
            lines.push(`${indentStr}      <body>`)
            lines.push(`${indentStr}        <p>${escapeXML(node.data!.note!)}</p>`)
            lines.push(`${indentStr}      </body>`)
            lines.push(`${indentStr}    </html>`)
            lines.push(`${indentStr}  </richcontent>`)
        }

        // 子节点
        for (const child of node.children) {
            generateNodeXML(child, lines, indent + 1)
        }

        lines.push(`${indentStr}</node>`)
    } else {
        lines.push(`${indentStr}<node ${attrs.join(' ')}/>`)
    }
}

/**
 * XML 转义
 */
function escapeXML(str: string): string {
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;')
}
